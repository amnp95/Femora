class GeneratesMeshMixin:
    """Mixin for interfaces that must create their own mesh (cells).

    This mixin provides a standardized way for components to generate and
    manage their own mesh data, which can then be integrated into a larger,
    assembled mesh.

    Attributes:
        interface_mesh: The mesh generated by this interface. Its specific
            type will depend on the concrete mesh implementation used (e.g.,
            a `femora.Mesh` object, or a list of element data).

    Example:
        >>> class MyMeshGenerator(GeneratesMeshMixin):
        ...     def build_mesh(self, num_elements: int):
        ...         self.interface_mesh = [f"element_{i}" for i in range(num_elements)]
        ...
        >>> generator = MyMeshGenerator()
        >>> generator.build_mesh(2)
        >>> print(generator.interface_mesh)
        ['element_0', 'element_1']
    """

    interface_mesh = None  # type: ignore

    def build_mesh(self, **kwargs):
        """Populate the internal `interface_mesh` attribute.

        This method must be overridden by concrete implementations of the mixin.
        It is responsible for generating the mesh relevant to the interface
        and storing it in `self.interface_mesh`.

        Args:
            **kwargs: Arbitrary keyword arguments that may be required for
                mesh generation, depending on the specific implementation.

        Raises:
            NotImplementedError: If the method is called directly on the mixin
                without being overridden by a subclass.

        Example:
            >>> class ConcreteMeshGenerator(GeneratesMeshMixin):
            ...     def build_mesh(self, num_nodes: int, element_type: str = "quad"):
            ...         # Simulate mesh generation
            ...         self.interface_mesh = [f"{element_type}_{i}" for i in range(num_nodes)]
            ...
            >>> generator = ConcreteMeshGenerator()
            >>> generator.build_mesh(num_nodes=3, element_type="triangle")
            >>> print(generator.interface_mesh)
            ['triangle_0', 'triangle_1', 'triangle_2']
        """
        raise NotImplementedError

    def integrate_mesh(self, assembled_mesh, **kwargs):
        """Optionally merge or attach the generated `interface_mesh` to the main assembled mesh.

        This method provides a hook for subclasses to integrate their
        `interface_mesh` into a larger, global `assembled_mesh`.
        The default implementation does nothing.

        Args:
            assembled_mesh: The main mesh object to which the interface's
                mesh should be integrated. Its type depends on the global
                mesh representation (e.g., `femora.Mesh`).
            **kwargs: Arbitrary keyword arguments that may be required for
                mesh integration.

        Example:
            >>> class MergingMeshGenerator(GeneratesMeshMixin):
            ...     def build_mesh(self):
            ...         self.interface_mesh = ["element_A", "element_B"]
            ...
            ...     def integrate_mesh(self, assembled_mesh, prefix="int_"):
            ...         if self.interface_mesh:
            ...             # Simulate extending a list-like assembled_mesh
            ...             assembled_mesh.extend([prefix + elm for elm in self.interface_mesh])
            ...
            >>> global_mesh = []
            >>> generator = MergingMeshGenerator()
            >>> generator.build_mesh()
            >>> generator.integrate_mesh(global_mesh, prefix="FEM_")
            >>> print(global_mesh)
            ['FEM_element_A', 'FEM_element_B']
        """
        pass


class GeneratesNodesMixin:
    """Mixin for interfaces that only add nodes, without generating cells.

    This mixin allows components to generate a set of nodes and optionally
    integrate them into a larger nodal collection or mesh structure.

    Attributes:
        new_nodes (list): A list of new nodes generated by this interface.
            Each element in the list typically represents a node, potentially
            a tuple of coordinates, a node object, or an identifier.

    Example:
        >>> class MyNodeGenerator(GeneratesNodesMixin):
        ...     def build_nodes(self, count: int, offset: float = 0.0):
        ...         self.new_nodes = [(i + offset, i + offset, 0.0) for i in range(count)]
        ...
        >>> generator = MyNodeGenerator()
        >>> generator.build_nodes(2, 10.0)
        >>> print(generator.new_nodes)
        [(10.0, 10.0, 0.0), (11.0, 11.0, 0.0)]
    """

    new_nodes = []  # type: ignore

    def build_nodes(self, **kwargs):
        """Populate the internal `new_nodes` attribute.

        This method must be overridden by concrete implementations of the mixin.
        It is responsible for generating the nodes relevant to the interface
        and storing them in `self.new_nodes`.

        Args:
            **kwargs: Arbitrary keyword arguments that may be required for
                node generation, depending on the specific implementation.

        Raises:
            NotImplementedError: If the method is called directly on the mixin
                without being overridden by a subclass.

        Example:
            >>> class ConcreteNodeGenerator(GeneratesNodesMixin):
            ...     def build_nodes(self, count: int, dim: int = 3):
            ...         # Simulate node generation (e.g., coordinates)
            ...         self.new_nodes = [(i,) * dim for i in range(count)]
            ...
            >>> generator = ConcreteNodeGenerator()
            >>> generator.build_nodes(count=2, dim=2)
            >>> print(generator.new_nodes)
            [(0, 0), (1, 1)]
        """
        raise NotImplementedError

    def integrate_nodes(self, assembled_mesh, **kwargs):
        """Optionally integrate the generated `new_nodes` into the main assembled mesh.

        This method provides a hook for subclasses to add their `new_nodes`
        to a larger, global `assembled_mesh` or a node container within it.
        The default implementation does nothing.

        Args:
            assembled_mesh: The main mesh object (or node container within the mesh)
                to which the interface's nodes should be integrated. Its type depends
                on the global mesh representation.
            **kwargs: Arbitrary keyword arguments that may be required for
                node integration.

        Example:
            >>> class NodeIntegrator(GeneratesNodesMixin):
            ...     def build_nodes(self):
            ...         self.new_nodes = [(1.0, 0.0), (2.0, 0.0)]
            ...
            ...     def integrate_nodes(self, assembled_mesh):
            ...         if self.new_nodes:
            ...             # Assuming assembled_mesh has a method to add nodes
            ...             for node in self.new_nodes:
            ...                 assembled_mesh.append(node)
            ...
            >>> global_node_list = []
            >>> integrator = NodeIntegrator()
            >>> integrator.build_nodes()
            >>> integrator.integrate_nodes(global_node_list)
            >>> print(global_node_list)
            [(1.0, 0.0), (2.0, 0.0)]
        """
        pass


class GeneratesConstraintsMixin:
    """Mixin for interfaces that create multi-point (MP) or single-point (SP) constraints.

    This mixin enables components to generate various types of constraints
    and provides a mechanism to register them with global constraint managers.

    Attributes:
        constraints (list): A list of constraint objects generated by this
            interface. The specific type of objects depends on the constraint
            representation (e.g., `femora.SPConstraint`, `femora.MPConstraint`).

    Example:
        >>> class MyConstraintGenerator(GeneratesConstraintsMixin):
        ...     def build_constraints(self, node_ids: list[int]):
        ...         # Simulate creating SP constraints
        ...         self.constraints = [f"SP_Node_{n}_DOF_X" for n in node_ids]
        ...
        >>> generator = MyConstraintGenerator()
        >>> generator.build_constraints(node_ids=[1, 2])
        >>> print(generator.constraints)
        ['SP_Node_1_DOF_X', 'SP_Node_2_DOF_X']
    """

    constraints = []  # type: ignore

    def build_constraints(self, **kwargs):
        """Populate the internal `constraints` attribute.

        This method must be overridden by concrete implementations of the mixin.
        It is responsible for generating the constraints relevant to the interface
        and storing them in `self.constraints`.

        Args:
            **kwargs: Arbitrary keyword arguments that may be required for
                constraint generation, depending on the specific implementation.

        Raises:
            NotImplementedError: If the method is called directly on the mixin
                without being overridden by a subclass.

        Example:
            >>> class ConcreteConstraintGenerator(GeneratesConstraintsMixin):
            ...     def build_constraints(self, fixed_nodes: list[int]):
            ...         # Simulate creating SP constraints for given nodes
            ...         self.constraints = [f"FixedNode_{node_id}" for node_id in fixed_nodes]
            ...
            >>> generator = ConcreteConstraintGenerator()
            >>> generator.build_constraints(fixed_nodes=[10, 20])
            >>> print(generator.constraints)
            ['FixedNode_10', 'FixedNode_20']
        """
        raise NotImplementedError

    def register_constraints(self):
        """Push the generated `constraints` to the global constraint managers.

        This method is responsible for taking the `self.constraints` list
        and registering them with the appropriate global single-point (SP)
        or multi-point (MP) constraint managers within the overall simulation
        framework. The default implementation does nothing.

        Example:
            >>> class ConstraintRegistrar(GeneratesConstraintsMixin):
            ...     def build_constraints(self):
            ...         self.constraints = ["SP_1", "MP_A"]
            ...
            ...     def register_constraints(self):
            ...         if self.constraints:
            ...             # Simulate pushing to global managers
            ...             for c in self.constraints:
            ...                 print(f"Registering: {c}")
            ...
            >>> registrar = ConstraintRegistrar()
            >>> registrar.build_constraints()
            >>> registrar.register_constraints()
            Registering: SP_1
            Registering: MP_A
        """
        pass


class HandlesDecompositionMixin:
    """Mixin that is notified when the mesh is repartitioned and may react.

    This mixin provides a hook for interfaces to update their internal state
    or data structures when the underlying numerical mesh is decomposed
    or repartitioned, for example, in parallel computing contexts.

    Example:
        >>> class MyDecompositionHandler(HandlesDecompositionMixin):
        ...     def __init__(self):
        ...         self.partition_version = 0
        ...
        ...     def on_partition_update(self, assembled_mesh, force_update: bool = False):
        ...         self.partition_version += 1
        ...         print(f"Mesh repartitioned. Current version: {self.partition_version}")
        ...         if force_update:
        ...             print("Performing forced update logic.")
        ...
        >>> handler = MyDecompositionHandler()
        >>> handler.on_partition_update(assembled_mesh=None)
        Mesh repartitioned. Current version: 1
        >>> handler.on_partition_update(assembled_mesh=None, force_update=True)
        Mesh repartitioned. Current version: 2
        Performing forced update logic.
    """

    def on_partition_update(self, assembled_mesh, **kwargs):
        """Update internal state after the core mesh arrays have changed due to repartitioning.

        This method is called by the system when the mesh undergoes a
        decomposition or repartitioning operation. Subclasses can override
        this method to synchronize their internal data structures with the
        new mesh layout or processor assignments. The default implementation does nothing.

        Args:
            assembled_mesh: The (potentially repartitioned) main mesh object.
                Its type depends on the global mesh representation (e.g., `femora.Mesh`).
            **kwargs: Arbitrary keyword arguments that may provide additional
                context about the partition update (e.g., `partition_id`).

        Example:
            >>> class StateSynchronizer(HandlesDecompositionMixin):
            ...     def __init__(self):
            ...         self._local_data = {}
            ...
            ...     def on_partition_update(self, assembled_mesh, partition_id: int):
            ...         # Simulate re-populating local data based on new partition
            ...         self._local_data = {f"node_{i}": f"data_p{partition_id}" for i in range(2)}
            ...         print(f"Updated local data for partition {partition_id}: {self._local_data}")
            ...
            >>> synchronizer = StateSynchronizer()
            >>> class MockMesh: pass
            >>> mesh = MockMesh() # A placeholder for a mesh object
            >>> synchronizer.on_partition_update(mesh, partition_id=0)
            Updated local data for partition 0: {'node_0': 'data_p0', 'node_1': 'data_p0'}
            >>> synchronizer.on_partition_update(mesh, partition_id=1)
            Updated local data for partition 1: {'node_0': 'data_p1', 'node_1': 'data_p1'}
        """
        pass